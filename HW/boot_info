#!/usr/bin/env python3
import hashlib
import os
import sys
import csv

SECTOR_SIZE = 512
#---------------------------------Load MBR Types---------------------------------
MBR_TYPES={}
def loadMbrTypes(path):
    global MBR_TYPES
    with open(path,'r') as f:
        reader=csv.reader(f)
        for row in reader:
            MBR_TYPES[row[0].lower()]=row[1]
    return MBR_TYPES

MBR_TYPES=loadMbrTypes("PartitionTypes.csv")
def createHashInfoDirectory():
    os.makedirs("hash_info", exist_ok=True)
#---------------------------------Hash Computation---------------------------------
def computeHashes(path):
    md5=hashlib.md5()
    sha256=hashlib.sha256()
    sha512=hashlib.sha512()

    with open(path,'rb') as f:
        while True:
            data=f.read(65536)
            if not data:
                break
            md5.update(data)
            sha256.update(data)
            sha512.update(data)

    md5_hash = md5.hexdigest()
    sha256_hash = sha256.hexdigest()
    sha512_hash = sha512.hexdigest()

    createHashInfoDirectory()
    with open(f"hash_info/MD5-{os.path.basename(path)}.txt",'w') as f1:
        f1.write(md5_hash+'\n')
    with open(f"hash_info/SHA-256-{os.path.basename(path)}.txt",'w') as f2:
        f2.write(sha256_hash+'\n')
    with open(f"hash_info/SHA-512-{os.path.basename(path)}.txt",'w') as f3:
        f3.write(sha512_hash+'\n')


    return {"md5": md5_hash, "sha256": sha256_hash, "sha512": sha512_hash}




# use offset to detect MBR signature
def detectMbrSignature(first_sector):
    mbrSignatureoffset = 510
    mbrSignature = first_sector[mbrSignatureoffset:mbrSignatureoffset + 2]
    if mbrSignature != b'\x55\xAA':
        return False
    return True

def isProtectiveMbr(firstSector):
    gptOffset = firstSector[446:462]
    if len(gptOffset)==16 and gptOffset[4]== 0xEE:
        return True
    return False

def detectGptHeader(file):
    file.seek(512,os.SEEK_SET)
    headerOffset = file.read(8)
    if headerOffset == b'EFI PART':
        return True
    return False
#---------------------------------Scheme Detection---------------------------------
#1.detect mbr signature
#2.check gpt protective mbr
#3.check gpt header
def detectScheme(path):
    with open(path, 'rb') as f:
        first=f.read(SECTOR_SIZE)
        if detectMbrSignature(first)==False:
            return "UNKNOWN"
        if isProtectiveMbr(first) and detectGptHeader(f):
            return "GPT"
        else:
            return "MBR"
#---------------------------------MBR Partition Extraction---------------------------------
def mbrPartitions(path):
    parts=[]
    with open(path,'rb') as f:
        f.seek(446,os.SEEK_SET)
        for i in range(4):
            part=f.read(16)
            partType=part[4]
            if partType !=0x00:
                parts.append({
                    "Partition Number": i+1,
                    "Type HEX": f"{partType:02X}",
                    "Partition Type": MBR_TYPES.get(f"{partType:02x}","Unknown"),
                    "Starting LBA": int.from_bytes(part[8:12],'little'),
                    "Size in Sectors": int.from_bytes(part[12:16],'little')
                })
    return parts

def print_mbr_lines(parts):
    for p in parts:
        start_byte_addr = p["Starting LBA"] * SECTOR_SIZE
        print(f"({p['Type HEX']}), {p['Partition Type']} , {start_byte_addr}, {p['Size in Sectors']}")
#---------------------------------Read 16 Bytes from Partition Offsets---------------------------------
def asciiBytes(data):
    asciiList = []
    for byte in data:
        if 32 <= byte <= 126:
            asciiList.append(chr(byte))
        else:
            asciiList.append('.')
    asciiList = "  ".join(asciiList)
    return asciiList

def read16bytesforPartitions(path,part,offset):
    results=[]
    with open(path,'rb') as f:
        for i in range(len(part)):
            p=part[i]
            offOrig=offset[i]
            off=offset[i] % SECTOR_SIZE

            f.seek(p["Starting LBA"] * SECTOR_SIZE + off, os.SEEK_SET)
            data = f.read(16)
            hexList = []

            for b in data:
                hexBytes= format(b,'02x')
                hexList.append(hexBytes)
            hexStr=" ".join(hexList)

            asciiStr = asciiBytes(data)
            results.append({
                "index": p["Partition Number"],
                "offset": offOrig,
                "hex": hexStr,
                "ascii": asciiStr
                })
    return results

#this print16bytesforPartitions use ChatGPT formatting
def print16bytesforPartitions(snips):
    for s in snips:
        print(f"Partition number: {s['index']}")
        prefix = f"16 bytes of boot record from offset {s['offset']}: "
        print(prefix + s['hex'])
        pad = max(1, len(prefix) - len("ASCII:"))
        print("ASCII:" + " " * pad + s['ascii'])


#---------------------------------GPT Partition Extraction---------------------------------
def gptPartitions(path):
    print("Reading GPT Partitions")
    parts=[]
    with open(path,'rb') as f:
        f.seek(1024,os.SEEK_SET)
        for i in range(128):
            part=f.read(128)
            partTypeGuid=part[0:16]
            if partTypeGuid != b'\x00'*16:
                startingLBA=int.from_bytes(part[32:40],'little')
                endingLBA=int.from_bytes(part[40:48],'little')
                name = part[56:128].decode('utf-16').rstrip('\x00')
                parts.append({
                    "Partition Number": i+1,
                    "Partition Type GUID": partTypeGuid.hex(),
                    "Starting LBA in Hex": hex(startingLBA),
                    "Ending LBA in Hex": hex(endingLBA),
                    "Starting LBA in Decimal": startingLBA,
                    "Ending LBA in Decimal": endingLBA,
                    "Partition name": name,
                })
    return parts

def print_gpt_lines(parts):
        for p in parts:
            print(f"Partition number: {p['Partition Number']}")
            print(f"Partition Type GUID : {p['Partition Type GUID']}")
            print(f"Starting LBA in hex: {p['Starting LBA in Hex']}")
            print(f"ending LBA in hex: {p['Ending LBA in Hex']}")
            print(f"starting LBA in Decimal: {p['Starting LBA in Decimal']}")
            print(f"ending LBA in Decimal: {p['Ending LBA in Decimal']}")
            print(f"Partition name: {p.get('Partition name','')}")
            print() 
        #---------------------------------Main Execution---------------------------------
if __name__ == "__main__":
    args = sys.argv
    try:
        filename=args[args.index('-f') + 1]
    except(ValueError):
        print("Error:missing -f <filename>.")
        sys.exit(1)

    offsets = []
    if "-o" in args:
        i = args.index("-o") + 1
        while i < len(args) and not args[i].startswith("-"):
            offsets.append(int(args[i]))
            i += 1
    hashes = computeHashes(filename)
    scheme = detectScheme(filename)

    if scheme == "MBR":
        print("MBR Partition Detected")
        partitions = mbrPartitions(filename)
        print("MBR Partitions:")
        print_mbr_lines(partitions)
        snips = read16bytesforPartitions(filename, partitions, offsets)
        print("16 Bytes from Partition Offsets:")
        print16bytesforPartitions(snips)
    elif scheme == "GPT":
        print("GPT Partition Detected")
        partitions = gptPartitions(filename)
        print("GPT Partitions:")
        print_gpt_lines(partitions)

    else:
        partitions = []
        print("UNKNOWN Partition Scheme Detected")
    #MBR_TYPES = loadMbrTypes("PartitionTypes.csv")
    #print(MBR_TYPES)

    print("Partition Scheme:", scheme)
    print("MD5:    ", hashes["md5"])
    print("SHA-256: ", hashes["sha256"])
    print("SHA-512: ", hashes["sha512"])
